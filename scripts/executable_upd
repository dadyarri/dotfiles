#!/bin/bash

# ARG_OPTIONAL_BOOLEAN([system],[s],[Update system packages])
# ARG_OPTIONAL_BOOLEAN([autoremove],[r],[Remove orphans automatically])
# ARG_OPTIONAL_BOOLEAN([flatpak],[f],[Update flatpak applications])
# ARG_OPTIONAL_BOOLEAN([neovim],[n],[Update neovim packages])
# ARG_OPTIONAL_BOOLEAN([bin],[b],[Update cli apps in ~/bin])
# ARG_OPTIONAL_BOOLEAN([npm],[j],[Update globally installed node.js packages])
# ARG_OPTIONAL_BOOLEAN([all],[a],[Enables all flags (same as -srfnb)])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[Enable verbose output],[on])
# ARG_HELP([Upd - little wrapper to update system])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='srfnbavh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_system="off"
_arg_autoremove="off"
_arg_flatpak="off"
_arg_neovim="off"
_arg_bin="off"
_arg_all="off"
_arg_verbose="on"


print_help()
{
	printf '%s\n' "Upd - little wrapper to update system"
	printf 'Usage: %s [-s|--(no-)system] [-r|--(no-)autoremove] [-f|--(no-)flatpak] [-n|--(no-)neovim] [-b|--(no-)bin] [-a|--(no-)all] [-v|--(no-)verbose] [-h|--help]\n' "$0"
	printf '\t%s\n' "-s, --system, --no-system: Update system packages (off by default)"
	printf '\t%s\n' "-r, --autoremove, --no-autoremove: Remove orphans automatically (off by default)"
	printf '\t%s\n' "-f, --flatpak, --no-flatpak: Update flatpak applications (off by default)"
	printf '\t%s\n' "-n, --neovim, --no-neovim: Update neovim packages (off by default)"
	printf '\t%s\n' "-b, --bin, --no-bin: Update cli apps in ~/bin (off by default)"
	printf '\t%s\n' "-a, --all, --no-all: Enables all flags (same as -srfnb) (off by default)"
	printf '\t%s\n' "-v, --verbose, --no-verbose: Enable verbose output (on by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-s|--no-system|--system)
				_arg_system="on"
				test "${1:0:5}" = "--no-" && _arg_system="off"
				;;
			-s*)
				_arg_system="on"
				_next="${_key##-s}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-r|--no-autoremove|--autoremove)
				_arg_autoremove="on"
				test "${1:0:5}" = "--no-" && _arg_autoremove="off"
				;;
			-r*)
				_arg_autoremove="on"
				_next="${_key##-r}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-f|--no-flatpak|--flatpak)
				_arg_flatpak="on"
				test "${1:0:5}" = "--no-" && _arg_flatpak="off"
				;;
			-f*)
				_arg_flatpak="on"
				_next="${_key##-f}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-f" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-n|--no-neovim|--neovim)
				_arg_neovim="on"
				test "${1:0:5}" = "--no-" && _arg_neovim="off"
				;;
			-n*)
				_arg_neovim="on"
				_next="${_key##-n}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-b|--no-bin|--bin)
				_arg_bin="on"
				test "${1:0:5}" = "--no-" && _arg_bin="off"
				;;
			-b*)
				_arg_bin="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-a|--no-all|--all)
				_arg_all="on"
				test "${1:0:5}" = "--no-" && _arg_all="off"
				;;
			-a*)
				_arg_all="on"
				_next="${_key##-a}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

if [[ $_arg_all == 'on' ]]; then
_arg_system="on"
_arg_autoremove="on"
_arg_flatpak="on"
_arg_neovim="on"
_arg_bin="on"
_arg_npm="on"
fi

if [[ $_arg_verbose == 'on' ]]; then
  ansi --faint "'system' is $_arg_system"
  ansi --faint "'autoremove' is $_arg_autoremove"
  ansi --faint "'flatpak' is $_arg_flatpak"
  ansi --faint "'neovim' is $_arg_neovim"
  ansi --faint "'bin' is $_arg_bin"
  ansi --faint "'npm' is $_arg_npm"
fi

ansi --blue "Updating system started..."
if [[ ($_arg_system == 'on') || ($_arg_autoremove == 'on') ]]; then
  ansi --red "Password required"
  password=$(askpass_stars)
  echo
fi

if [[ $_arg_system == 'on' ]]; then
  ansi --blue "Updating packages..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="sudo -S dnf update -y"
  else
    cmd="sudo -S dnf update -yq"
  fi

  if printf "%s\n" "$password" | eval "$cmd"; then
    ansi --green "Packages updated."
  else
    ansi --red "Error occured."
  fi

  echo
fi

if [[ $_arg_autoremove == 'on' ]]; then
  ansi --blue "Removing orphans..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="sudo -S dnf autoremove -y"
  else
    cmd="sudo -S dnf autoremove -yq"
  fi

  if echo "$password" | eval "$cmd"; then
    ansi --green "Orphans removed."
  else
    ansi --red "Error occured"
  fi

  echo
fi

if [[ $_arg_flatpak == 'on' ]]; then
  ansi --blue "Updating flatpak apps..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="flatpak update -y"
  else
    cmd="flatpak update -y --noninteractive > /dev/null"
  fi

  if eval "$cmd"; then
    ansi --green "Flatpak apps updated."
  else
    ansi --red "Error occured."
  fi

  echo
fi

if [[ $_arg_neovim == 'on' ]]; then
  ansi --blue "Updating neovim's plugins..."

  if nvim --headless +PackerUpdate +qa; then
    ansi --green "Neovim's plugins updated."
  else
    ansi --red "Error occured."
  fi
  echo
fi

if [[ $_arg_bin == 'on' ]]; then
  ansi --blue "Updating binaries in ~/bin..."

  printf "  "
  ansi --blue "Updating chezmoi..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="chezmoi upgrade"
  else
    cmd="chezmoi upgrade > /dev/null"
  fi


  if eval "$cmd"; then
    printf "  "
    ansi --green "Chezmoi updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi

  # --------

  for script in $(fd -e nim --full-path "/home/$USER/scripts/src" -t f); do
    echo
    printf "  "
    filename=$(basename "$script")
    fn="${filename%.*}"
    ansi --blue "Updating $fn..."

    if [[ $_arg_verbose == "on" ]]; then
      cmd="nim -d:release --opt:size c $script && mv ~/scripts/src/$fn ~/bin"
    else
      cmd="nim -d:release --opt:size --hints:off c $script && mv ~/scripts/src/$fn ~/bin"
    fi

    if eval "$cmd"; then
      printf "  "
      ansi --green "$fn updated."
    else
      printf "  "
      ansi --red "Error occured."
    fi
  done
  # -------

  echo
  printf "  "
  ansi --blue "Updating xplr..."

  kernel_name=$(uname -s)
  xplr_url="https://github.com/sayanarijit/xplr/releases/latest/download/xplr-${kernel_name,,}.tar.gz"

  if [[ $_arg_verbose == "on" ]]; then
    cmd="curl -LO $xplr_url"
  else
    cmd="curl -LOs $xplr_url"
  fi

  if eval "$cmd" && tar xzf "xplr-${kernel_name,,}.tar.gz" -C ~/bin && rm -rf "xplr-${kernel_name,,}.tar.gz"; then
    printf "  "
    ansi --green "Xplr updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi

  # --------

  echo
  printf "  "
  ansi --blue "Updating nimble packages..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="nim e ~/scripts/src/updnimp.nim"
  else
    cmd="nim e ~/scripts/src/updnimp.nim > /dev/null"
  fi

  if eval "$cmd"; then
    printf "  "
    ansi --green "Nimble packages updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi

  # --------

  echo
  printf "  "
  ansi --blue "Updating nim & choosenim..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="choosenim update stable; choosenim update self"
  else
    cmd="choosenim update stable; choosenim update self > /dev/null"
  fi

  if eval "$cmd"; then
    printf "  "
    ansi --green "Nim & choosenim updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi

  echo
  printf "  "
  ansi --blue "Updating sheldon..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="curl --proto '=https' -fLsS https://rossmacarthur.github.io/install/crate.sh \
    | bash -s -- --repo rossmacarthur/sheldon --to ~/bin --force"
  else
    cmd="curl --proto '=https' -fLsS https://rossmacarthur.github.io/install/crate.sh \
    | bash -s -- --repo rossmacarthur/sheldon --to ~/bin --force > /dev/null"
  fi

  if eval "$cmd"; then
    printf "  "
    ansi --green "Sheldon updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi


  echo
  printf "  "
  ansi --blue "Updating zsh plugins..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="sheldon lock --update"
  else
    cmd="sheldon lock --update > /dev/null"
  fi

  if eval "$cmd"; then
    printf "  "
    ansi --green "Zsh plugins updated."
  else
    printf "  "
    ansi --red "Error occured."
  fi
fi

if [[ $_arg_npm == "on" ]]; then
  ansi --blue "Updating npm packages..."

  if [[ $_arg_verbose == "on" ]]; then
    cmd="npm -g update"
  else
    cmd="npm -g update > /dev/null"
  fi

  if eval "$cmd"; then
    ansi --green "Npm packages updated."
  else
    ansi --red "Error occured."
  fi
fi
echo
ansi --green "System updated."

# ] <-- needed because of Argbash
